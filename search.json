[{"title":"leetcode symmetric-tree","url":"/2020/03/04/leetcode-symmetric-tree/","content":"\n## 传送门\n\nhttps://leetcode-cn.com/problems/symmetric-tree/\n\n## 大意\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n## 思路\n\n首先题目要求是否镜像，如果一个树的左子树与右子树镜像对称，那么这个树是对称的。那么很容易可以想到，可以抽象成以下过程：\n\n1. 比较A、B是否相同\n2. 比较A的左节点、B的右节点是否相同\n3. 比较A的右节点、B的左节点是否相同\n\n所以代码很容易就实现了，初始情况下可以传入root节点与自身比较。\n\n## 代码\n\n``` go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc check(a, b *TreeNode) bool {\n    if a == nil && b == nil {\n        return true\n    }\n    if a == nil || b == nil {\n        return false\n    }\n    return a.Val == b.Val && check(a.Left, b.Right) && check(a.Right, b.Left)\n}\n\nfunc isSymmetric(root *TreeNode) bool {\n    return check(root, root)\n}\n\n```\n","tags":["二叉树"]},{"title":"hdu2063","url":"/2017/09/03/hdu2063/","content":"\n## 传送门\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2063\n\n## 大致题意\n\nRPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？\n\n## 题目分析\n\n二分图求最大匹配，使用匈牙利算法。\n\n匈牙利算法：增广路径、递归\n\n\n## code\n\n```\n#include<cstdio>  \n#include<cstring>  \n#include<iostream>  \n#include<queue>  \n#include<vector>  \n#include<cmath>  \n#include<algorithm>  \nusing namespace std;\nconst int N = 505;\nint line[N][N];\nint girl[N], used[N];\nint k, m, n;\nbool found(int x)\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (line[x][i] && !used[i])\n\t\t{\n\t\t\tused[i] = 1;\n\t\t\tif (girl[i] == 0 || found(girl[i]))\n\t\t\t{\n\t\t\t\tgirl[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint x, y;\n\twhile (scanf(\"%d\", &k) && k)\n\t{\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tmemset(line, 0, sizeof(line));\n\t\tmemset(girl, 0, sizeof(girl));\n\t\tfor (int i = 0; i<k; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tline[x][y] = 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (found(i)) sum++;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}\n\n```\n","tags":["图论","qianyu"]},{"title":"poj1679","url":"/2017/09/03/poj1679/","content":"\n## 传送门\n\nhttp://poj.org/problem?id=1679\n\n## 大致题意\n\n给定图，让求它的最小生成树是否唯一。如果唯一的话输出最小生成树的权值和，否则输出Not Unique!\n\n## 题目分析\n\n判断最小生成树是否唯一，可以先求最小生成树，再求次小生成树，比较两者路径长度是否相同。注意需要判断不存在最小生成树的情况。\n\n次小生成树：求出最小生成树之后，枚举去掉每条边的新最小生成树，取最小值\n\n## code\n\n```\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int maxn = 111;\nconst int inf = 0x3f3f3f3f;\nint Map[maxn][maxn];//邻接矩阵存图\nint Max[maxn][maxn];//表示最小生成树中i到j的最大边权\nbool used[maxn][maxn];//判断该边是否加入最小生成树\nint pre[maxn];\nint dis[maxn];\nvoid init(int n)\n{\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (i == j) Map[i][j] = 0;\n\t\t\telse Map[i][j] = inf;\n}\nvoid read(int m)\n{\n\tint u, v, w;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tMap[u][v] = Map[v][u] = w;\n\t}\n}\nint prim(int n)\n{\n\tint ans = 0;\n\tbool vis[maxn];\n\tmemset(vis, false, sizeof(vis));\n\tmemset(used, false, sizeof(used));\n\tmemset(Max, 0, sizeof(Max));\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tdis[i] = Map[1][i];\n\t\tpre[i] = 1;\n\t}\n\tpre[1] = 0;\n\tdis[1] = 0;\n\tvis[1] = true;\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint min_dis = inf, k;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (!vis[j] && min_dis > dis[j])\n\t\t\t{\n\t\t\t\tmin_dis = dis[j];\n\t\t\t\tk = j;\n\t\t\t}\n\t\t}\n\t\tif (min_dis == inf) return -1;//如果不存在最小生成树\n\t\tans += min_dis;\n\t\tvis[k] = true;\n\t\tused[k][pre[k]] = used[pre[k]][k] = true;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (vis[j]) Max[j][k] = Max[k][j] = max(Max[j][pre[k]], dis[k]);\n\t\t\tif (!vis[j] && dis[j] > Map[k][j])\n\t\t\t{\n\t\t\t\tdis[j] = Map[k][j];\n\t\t\t\tpre[j] = k;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;//最小生成树的权值之和\n}\nint smst(int n, int min_ans)//min_ans 是最小生成树的权值和\n{\n\tint ans = inf;\n\tfor (int i = 1; i <= n; i++)//枚举最小生成树之外的边\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (Map[i][j] != inf && !used[i][j])\n\t\t\t\tans = min(ans, min_ans + Map[i][j] - Max[i][j]);\n\tif (ans == inf) return -1;\n\treturn ans;\n}\nvoid solve(int n)\n{\n\tint ans = prim(n);\n\tif (ans == -1)\n\t{\n\t\tputs(\"Not Unique!\");\n\t\treturn;\n\t}\n\tif (smst(n, ans) == ans)\n\t\tprintf(\"Not Unique!\\n\");\n\telse\n\t\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tint T, n, m;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tinit(n);\n\t\tread(m);\n\t\tsolve(n);\n\t}\n\treturn 0;\n}\n```\n","tags":["图论","qianyu"]},{"title":"poj3463","url":"/2017/09/03/poj3463/","content":"\n## 传送门\n\nhttp://poj.org/problem?id=3463\n\n## 大致题意\n\n旅行团每天固定的从S地出发到达T地，为了省油要求尽量走最短路径或比最短路径长1单位距离的路径，求满足条件的路径条数\n\n## 题目分析\n\n由题意可得，求图的最短路次短路的长度以及方案数。\n\ndijkstra求最短路、次短路\n\n核心思路：\n\n1. if(x<最小)更新最小，次小；\n2. else if(x==最小)更新方法数；\n3. else if(x<次小)更新次小；\n4. else if(x==次小)更新方法数；\n\n循环：需要循环2*n-1次，最短路需要循环n-1次，次短路需要循环n次\n\n## code\n\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int VM = 1010;\nconst int EM = 10010;\n\nstruct Edge{\n\tint to, nxt;\n\tint cap;\n}edge[EM << 1];\n\nint vis[VM][2], dis[VM][2];  // dis[i][0]：到点i的最短路   dis[i][1]：到点j的次短路\nint head[VM], num[VM][2];  // num[i][0]：到点i的最短路的路数   len[i][1]：到点j的次短路的路数\nint n, m, cnt;\n\nvoid addedge(int cu, int cv, int cw){\n\tedge[cnt].to = cv;\n\tedge[cnt].cap = cw;\n\tedge[cnt].nxt = head[cu];\n\thead[cu] = cnt++;\n}\n\nvoid Dijkstra(int src, int des){\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(num, 0, sizeof(num));\n\tint i = 0;\n\tfor (i = 1; i <= n; i++){\n\t\tdis[i][0] = INF;\n\t\tdis[i][1] = INF;\n\t}\n\tdis[src][0] = 0;\n\tnum[src][0] = 1;\n\tint j, k, tmp, flag;\n\tfor (i = 1; i <= 2 * n - 1; i++){\n\t\ttmp = INF;    // 找新的最短路和次短路\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tif (!vis[j][0] && tmp>dis[j][0]){\n\t\t\t\tk = j;\n\t\t\t\tflag = 0;\n\t\t\t\ttmp = dis[j][0];\n\t\t\t}\n\t\t\telse if (!vis[j][1] && tmp>dis[j][1]){\n\t\t\t\tk = j;\n\t\t\t\tflag = 1;\n\t\t\t\ttmp = dis[j][1];\n\t\t\t}\n\t\t\tif (tmp == INF)    // 如果最短路和次短路都不存在，则退出for循环\n\t\t\t\tbreak;\n\t\t\tvis[k][flag] = 1;\n\t\t\tfor (j = head[k]; j != -1; j = edge[j].nxt){ // 更新和点k相连的边\n\t\t\t\tint v = edge[j].to;\n\t\t\t\tif (dis[v][0]>tmp + edge[j].cap){  // 比最短路短\n\t\t\t\t\tdis[v][1] = dis[v][0];\n\t\t\t\t\tnum[v][1] = num[v][0];\n\t\t\t\t\tdis[v][0] = tmp + edge[j].cap;\n\t\t\t\t\tnum[v][0] = num[k][flag];\n\t\t\t\t}\n\t\t\t\telse if (dis[v][0] == tmp + edge[j].cap){   // 等于最短路\n\t\t\t\t\tnum[v][0] += num[k][flag];\n\t\t\t\t}\n\t\t\t\telse if (dis[v][1]>tmp + edge[j].cap){    // 比次短路短\n\t\t\t\t\tdis[v][1] = tmp + edge[j].cap;\n\t\t\t\t\tnum[v][1] = num[k][flag];\n\t\t\t\t}\n\t\t\t\telse if (dis[v][1] == tmp + edge[j].cap){   // 等于次短路\n\t\t\t\t\tnum[v][1] += num[k][flag];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif (dis[des][1] == dis[des][0] + 1)\n\t\tnum[des][0] += num[des][1];\n\tprintf(\"%d\\n\", num[des][0]);\n}\n\nint main(){\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--){\n\t\tcnt = 0;\n\t\tmemset(head, -1, sizeof(head));\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tint u, v, w;\n\t\twhile (m--){\n\t\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\t\taddedge(u, v, w);\n\t\t}\n\t\tint src, des;\n\t\tscanf(\"%d%d\", &src, &des);\n\t\tDijkstra(src, des);\n\t}\n\treturn 0;\n}\n```\n","tags":["图论","qianyu"]},{"title":"hdu5950","url":"/2017/08/23/hdu5950/","content":"\n## 题目\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=5950\n\n## 大意\n\n$ f(n) = 2 * f(n - 2) + f(n - 1) + n^4 $ ，给定 n ,f(1),f(2)，求f(n)\n\n## 思路\n\n马上想到了这个题目，去年沈阳区域赛卡了好久的一道题。首先我们发现如果没有 `n^4` 这一项，那么这就是一个简单的线性递推，直接矩阵快速幂就好了。但是由于多了 `n^4` ，直觉上来看，这是一个无法由 `(n - 1)^4` 通过线性运算得到的项。 很自然地考虑拆项，把 `n^4` 拆成 `(n - 1 + 1)^4` 然后展开，我们发现，整个式子就可以进行线性递推了，于是我们构造矩阵跑一下矩阵快速幂即可\n\n","tags":["矩阵快速幂","sty"]},{"title":"hdu4587","url":"/2017/08/22/hdu4587/","content":"\n## 传送门\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4587\n\n## 大致题意\n\n给一个无向图，求去掉图中连个点，能形成的最多连通分量数。\n\n## 题目分析\n\n首先一看就是图论题，去掉点、形成连通分量，很容易联想到求割点。所以这道题其实就是个求割点的变形。需要在求割点的时候记录每个割点的子连通分量数即可。然后处理去掉两个点的方法很暴力，枚举去掉的第一个点，然后再跑tarjan就好了……\n\n## 战绩\n\n被三杀。。三次WA\n\n第一次是memset没加头文件，ce了……第二次是忘记要多组输入……第三次是加了多次输入，scanf没加&\n\n## code\n\n（注释掉的stack是栈，可用于连通分量的输出，cut是记录u是否是割点，本题不需要）\n\n```\n#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN = 5010;\nconst int MAXM = 10010;\n\n\nint m, n;\nint head[MAXN], total = 0;\n\nint DFN[MAXN];\nint LOW[MAXN];\n\nbool visit[MAXN];\n\nint block_count[MAXN];\n\nstruct Edge {\n    int to, next;\n}edges[MAXM];\n\nint first_u = 0;\nint index = 0;\n\n// bool cut[MAXN];\n// int stack[MAXN];\n// int top;\n\nvoid addEdge(int u, int v)\n{\n    edges[total].to = v;\n    edges[total].next = head[u];\n    head[u] = total++;\n}\n\nvoid tarjan(int u, int pre)\n{\n    int v;\n    DFN[u] = LOW[u] = ++index;\n    visit[u] = true;\n    // stack[top++] = u;\n    int son_num = 0;\n    for (int i = head[u]; i != -1; i = edges[i].next)\n    {\n        v = edges[i].to;\n        if (v == first_u) continue;\n        if (!DFN[v])\n        {\n            son_num++;\n            tarjan(v, u);\n            LOW[u] = min(LOW[u], LOW[v]);\n            if (u != pre && LOW[v] >= DFN[u])\n            {\n                // cut[u] = true;\n                block_count[u]++;\n            }\n        }\n        else if (visit[v])\n        {\n            LOW[u] = min(LOW[u], DFN[v]);\n        }\n    }\n    // if(u == pre && son > 1)cut[u] = true;\n    if (u == pre) block_count[u] = son_num - 1;\n    return;\n}\n\nint work(int N)\n{\n    memset(DFN, 0, sizeof(DFN));\n    memset(visit, false, sizeof(visit));\n    memset(block_count, 0, sizeof(block_count));\n    index = 0;\n    int cnt = 0;\n    int ans = 0;\n    for (int i = 0; i < N; i++)\n        if (i != first_u && !DFN[i])\n        {\n            tarjan(i, i);\n            cnt++;\n        }\n    for (int i = 0; i < N; i++)\n        if (i != first_u)\n            ans = max(ans, cnt + block_count[i]);\n    return ans;\n\n}\n\nint main() {\n\n    int u, v;\n\n\n    while (scanf(\"%d%d\", &n, &m) != EOF) \n    {\n        total = 0;\n        memset(head, -1, sizeof(head));\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            addEdge(u, v);\n            addEdge(v, u);\n        }\n\n        int ans = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            first_u = i;\n            ans = max(ans, work(n));\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}\n\n```\n\n\n## 反思\n\n思路虽然清晰，但是眼神太差，细节太垃圾，需要保持好手感……","tags":["图论","qianyu"]}]